<!-- nav -->

[Index](README.md)
| [Installation](installation.md)
| [Introduction](introduction.md)
| [API Overview](api-overview.md)
| [Package Console](package-console.md)
| [Changelog](changelog.md)
| [Uninstallation](uninstallation.md)

<!-- navstop -->

NOTE: This method overview is generated from the package specification in `sources/CONSOLE.pks`.

<!-- DO NOT EDIT THIS FILE DIRECTLY - it is generated from source file sources/CONSOLE.pks -->
<!-- markdownlint-disable MD003 MD012 MD024 MD033 -->

Oracle Instrumentation Console
==============================

- [Package console](#package-console)
- [Function my_client_identifier](#function-my_client_identifier)
- [Function my_log_level](#function-my_log_level)
- [Procedure error_save_stack](#procedure-error_save_stack)
- [Procedure error](#procedure-error)
- [Function error](#function-error)
- [Procedure warn](#procedure-warn)
- [Function warn](#function-warn)
- [Procedure info](#procedure-info)
- [Function info](#function-info)
- [Procedure log](#procedure-log)
- [Function log](#function-log)
- [Procedure debug](#procedure-debug)
- [Function debug](#function-debug)
- [Procedure trace](#procedure-trace)
- [Function trace](#function-trace)
- [Procedure count](#procedure-count)
- [Procedure count_reset](#procedure-count_reset)
- [Procedure count_current](#procedure-count_current)
- [Procedure count_end](#procedure-count_end)
- [Function count_current](#function-count_current)
- [Function count_end](#function-count_end)
- [Procedure time](#procedure-time)
- [Procedure time_reset](#procedure-time_reset)
- [Procedure time_current](#procedure-time_current)
- [Procedure time_end](#procedure-time_end)
- [Function time_current](#function-time_current)
- [Function time_end](#function-time_end)
- [Procedure table#](#procedure-table)
- [Procedure assert](#procedure-assert)
- [Procedure assertf](#procedure-assertf)
- [Procedure add_param](#procedure-add_param)
- [Function format](#function-format)
- [Procedure action](#procedure-action)
- [Procedure module](#procedure-module)
- [Function level_error](#function-level_error)
- [Function level_warning](#function-level_warning)
- [Function level_info](#function-level_info)
- [Function level_debug](#function-level_debug)
- [Function level_trace](#function-level_trace)
- [Function level_is_warning](#function-level_is_warning)
- [Function level_is_info](#function-level_is_info)
- [Function level_is_debug](#function-level_is_debug)
- [Function level_is_trace](#function-level_is_trace)
- [Function level_is_warning_yn](#function-level_is_warning_yn)
- [Function level_is_info_yn](#function-level_is_info_yn)
- [Function level_is_debug_yn](#function-level_is_debug_yn)
- [Function level_is_trace_yn](#function-level_is_trace_yn)
- [Function apex_error_handling](#function-apex_error_handling)
- [Function apex_plugin_render](#function-apex_plugin_render)
- [Function apex_plugin_ajax](#function-apex_plugin_ajax)
- [Procedure conf](#procedure-conf)
- [Procedure init](#procedure-init)
- [Procedure init](#procedure-init-1)
- [Procedure exit](#procedure-exit)
- [Procedure exit_all](#procedure-exit_all)
- [Function version](#function-version)
- [Procedure generate_param_trace](#procedure-generate_param_trace)
- [Function split_to_table](#function-split_to_table)
- [Function split](#function-split)
- [Function join](#function-join)
- [Function to_yn](#function-to_yn)
- [Function to_string](#function-to_string)
- [Function to_bool](#function-to_bool)
- [Function to_html_table](#function-to_html_table)
- [Function to_md_code_block](#function-to_md_code_block)
- [Function to_md_tab_header](#function-to_md_tab_header)
- [Function to_md_tab_data](#function-to_md_tab_data)
- [Function to_unibar](#function-to_unibar)
- [Procedure print](#procedure-print)
- [Procedure printf](#procedure-printf)
- [Function runtime](#function-runtime)
- [Function runtime_seconds](#function-runtime_seconds)
- [Function runtime_milliseconds](#function-runtime_milliseconds)
- [Function level_name](#function-level_name)
- [Function scope](#function-scope)
- [Function call_stack](#function-call_stack)
- [Function apex_env](#function-apex_env)
- [Function cgi_env](#function-cgi_env)
- [Function user_env](#function-user_env)
- [Function console_env](#function-console_env)
- [Procedure clob_append](#procedure-clob_append)
- [Procedure clob_append](#procedure-clob_append-1)
- [Procedure clob_flush_cache](#procedure-clob_flush_cache)
- [Function status](#function-status)
- [Function conf](#function-conf)
- [Function client_prefs](#function-client_prefs)
- [Procedure purge](#procedure-purge)
- [Procedure purge_all](#procedure-purge_all)
- [Procedure purge_job_create](#procedure-purge_job_create)
- [Procedure purge_job_drop](#procedure-purge_job_drop)
- [Procedure purge_job_enable](#procedure-purge_job_enable)
- [Procedure purge_job_disable](#procedure-purge_job_disable)
- [Procedure purge_job_run](#procedure-purge_job_run)


## Package console

An instrumentation tool for Oracle developers. Save to install on production and
mostly API compatible with the [JavaScript
console](https://developers.google.com/web/tools/chrome-devtools/console/api).

For more infos have a look at the [project page on
GitHub](https://github.com/ogobrecht/console).

SIGNATURE

```sql
package console authid definer is

c_name    constant varchar2 ( 30 byte ) := 'Oracle Instrumentation Console'       ;
c_version constant varchar2 ( 10 byte ) := '1.1.1'                                ;
c_url     constant varchar2 ( 36 byte ) := 'https://github.com/ogobrecht/console' ;
c_license constant varchar2 (  3 byte ) := 'MIT'                                  ;
c_author  constant varchar2 ( 15 byte ) := 'Ottmar Gobrecht'                      ;
```


## Function my_client_identifier

Returns the current session identifier of the own session. This information is cached in a
package variable and determined on package initialization.

```sql
select console.my_client_identifier from dual;
```

SIGNATURE

```sql
function my_client_identifier return varchar2;
```


## Function my_log_level

Returns the current log level of the own session. This information is cached in a
package variable for performance reasons and re-evaluated every 10 seconds.

```sql
select console.my_log_level from dual;
```

SIGNATURE

```sql
function my_log_level return integer;
```


## Procedure error_save_stack

Saves the error stack, so that you are able to handle the error on the most
outer point in your code without loosing detail information of the original
error nested deeper in your code.

With this method we try to prevent log spoiling  - if you use it right you can
have ONE log entry for your errors with the saved details where the error
occured.

EXAMPLE

```sql
set define off
set feedback off
set serveroutput on
set linesize 120
set pagesize 40
column call_stack heading "Call Stack" format a120
whenever sqlerror exit sql.sqlcode rollback

prompt TEST ERROR_SAVE_STACK

prompt - compile package spec
create or replace package some_api is
  procedure do_stuff;
end;
/

prompt - compile package body
create or replace package body some_api is
------------------------------------------------------------------------------
    procedure do_stuff is
    --------------------------------------
        procedure sub1 is
        --------------------------------------
            procedure sub2 is
            --------------------------------------
                procedure sub3 is
                begin
                  console.assert(1 = 2, 'Demo');
                exception --sub3
                  when others then
                    console.error_save_stack;
                    raise;
                end;
            --------------------------------------
            begin
              sub3;
            exception --sub2
              when others then
                console.error_save_stack;
                raise;
            end;
        --------------------------------------
        begin
          sub2;
        exception --sub1
          when others then
            console.error_save_stack;
            raise no_data_found;
        end;
    --------------------------------------
    begin
      sub1;
    exception --do_stuff
      when others then
        console.error;
        raise;
    end;
------------------------------------------------------------------------------
end;
/

prompt - call the package
begin
  some_api.do_stuff;
exception
  when others then
    null; --> I know, I know, never do that without a final raise...
          --> But we want only test our logging without killing the script run...
end;
/

prompt - FINISHED, selecting now the call stack from the last log entry...

select call_stack from console_logs order by log_id desc fetch first row only;
```

EXAMPLE OUTPUT

```bash
TEST ERROR_SAVE_STACK
- compile package spec
- compile package body
- call the package
- FINISHED, selecting now the call stack from the last log entry...

Call Stack
------------------------------------------------------------------------------------------------------------------------
#### Saved Error Stack

- PLAYGROUND.SOME_API.DO_STUFF.SUB1.SUB2.SUB3, line 14 (line 11, ORA-20777 Assertion failed: Demo)
- PLAYGROUND.SOME_API.DO_STUFF.SUB1.SUB2, line 22 (line 19)
- PLAYGROUND.SOME_API.DO_STUFF.SUB1, line 30 (line 27)
- PLAYGROUND.SOME_API.DO_STUFF, line 38 (line 35, ORA-01403 no data found)

#### Call Stack

- PLAYGROUND.SOME_API.DO_STUFF, line 38
- __anonymous_block, line 2

#### Error Stack

- ORA-01403 no data found
- ORA-06512 at "PLAYGROUND.SOME_API", line 31
- ORA-20777 Assertion failed: Test assertion with line break.
- ORA-06512 at "PLAYGROUND.SOME_API", line 23
- ORA-06512 at "PLAYGROUND.SOME_API", line 15
- ORA-06512 at "PLAYGROUND.CONSOLE", line 750
- ORA-06512 at "PLAYGROUND.SOME_API", line 11
- ORA-06512 at "PLAYGROUND.SOME_API", line 19
- ORA-06512 at "PLAYGROUND.SOME_API", line 27

#### Error Backtrace

- PLAYGROUND.SOME_API, line 31
- PLAYGROUND.SOME_API, line 23
- PLAYGROUND.SOME_API, line 15
- PLAYGROUND.CONSOLE, line 750
- PLAYGROUND.SOME_API, line 11
- PLAYGROUND.SOME_API, line 19
- PLAYGROUND.SOME_API, line 27
- PLAYGROUND.SOME_API, line 35
```

SIGNATURE

```sql
procedure error_save_stack;
```


## Procedure error

Log a message with the level 1 (error).

SIGNATURE

```sql
procedure error (
  p_message         in clob     default null  , -- The log message itself
  p_permanent       in boolean  default false , -- Should the log entry be permanent (not deleted by purge methods)
  p_call_stack      in boolean  default true  , -- Include call stack
  p_apex_env        in boolean  default false , -- Include APEX environment
  p_cgi_env         in boolean  default false , -- Include CGI environment
  p_console_env     in boolean  default false , -- Include Console environment
  p_user_env        in boolean  default false , -- Include user environment
  p_user_agent      in varchar2 default null  , -- User agent of browser or other client technology
  p_user_scope      in varchar2 default null  , -- Override PL/SQL scope
  p_user_error_code in integer  default null  , -- Override PL/SQL error code
  p_user_call_stack in varchar2 default null    -- Override PL/SQL call stack
);
```


## Function error

Log a message with the level 1 (error). Returns the log ID.

SIGNATURE

```sql
function error (
  p_message         in clob     default null  ,
  p_permanent       in boolean  default false ,
  p_call_stack      in boolean  default true  ,
  p_apex_env        in boolean  default false ,
  p_cgi_env         in boolean  default false ,
  p_console_env     in boolean  default false ,
  p_user_env        in boolean  default false ,
  p_user_agent      in varchar2 default null  ,
  p_user_scope      in varchar2 default null  ,
  p_user_error_code in integer  default null  ,
  p_user_call_stack in varchar2 default null  )
return console_logs.log_id%type;
```


## Procedure warn

Log a message with the level 2 (warning).

SIGNATURE

```sql
procedure warn (
  p_message         in clob     default null  ,
  p_permanent       in boolean  default false ,
  p_call_stack      in boolean  default false ,
  p_apex_env        in boolean  default false ,
  p_cgi_env         in boolean  default false ,
  p_console_env     in boolean  default false ,
  p_user_env        in boolean  default false ,
  p_user_agent      in varchar2 default null  ,
  p_user_scope      in varchar2 default null  ,
  p_user_error_code in integer  default null  ,
  p_user_call_stack in varchar2 default null  );
```


## Function warn

Log a message with the level 2 (warning). Returns the log ID.

SIGNATURE

```sql
function warn (
  p_message         in clob     default null  ,
  p_permanent       in boolean  default false ,
  p_call_stack      in boolean  default false ,
  p_apex_env        in boolean  default false ,
  p_cgi_env         in boolean  default false ,
  p_console_env     in boolean  default false ,
  p_user_env        in boolean  default false ,
  p_user_agent      in varchar2 default null  ,
  p_user_scope      in varchar2 default null  ,
  p_user_error_code in integer  default null  ,
  p_user_call_stack in varchar2 default null  )
return console_logs.log_id%type;
```


## Procedure info

Log a message with the level 3 (info).

SIGNATURE

```sql
procedure info (
  p_message         in clob     default null  ,
  p_permanent       in boolean  default false ,
  p_call_stack      in boolean  default false ,
  p_apex_env        in boolean  default false ,
  p_cgi_env         in boolean  default false ,
  p_console_env     in boolean  default false ,
  p_user_env        in boolean  default false ,
  p_user_agent      in varchar2 default null  ,
  p_user_scope      in varchar2 default null  ,
  p_user_error_code in integer  default null  ,
  p_user_call_stack in varchar2 default null  );
```


## Function info

Log a message with the level 3 (info). Returns the log ID.

SIGNATURE

```sql
function info (
  p_message         in clob     default null  ,
  p_permanent       in boolean  default false ,
  p_call_stack      in boolean  default false ,
  p_apex_env        in boolean  default false ,
  p_cgi_env         in boolean  default false ,
  p_console_env     in boolean  default false ,
  p_user_env        in boolean  default false ,
  p_user_agent      in varchar2 default null  ,
  p_user_scope      in varchar2 default null  ,
  p_user_error_code in integer  default null  ,
  p_user_call_stack in varchar2 default null  )
return console_logs.log_id%type;
```


## Procedure log

Log a message with the level 3 (info).

SIGNATURE

```sql
procedure log (
  p_message         in clob     default null  ,
  p_permanent       in boolean  default false ,
  p_call_stack      in boolean  default false ,
  p_apex_env        in boolean  default false ,
  p_cgi_env         in boolean  default false ,
  p_console_env     in boolean  default false ,
  p_user_env        in boolean  default false ,
  p_user_agent      in varchar2 default null  ,
  p_user_scope      in varchar2 default null  ,
  p_user_error_code in integer  default null  ,
  p_user_call_stack in varchar2 default null  );
```


## Function log

Log a message with the level 3 (info). Returns the log ID.

SIGNATURE

```sql
function log (
  p_message         in clob     default null  ,
  p_permanent       in boolean  default false ,
  p_call_stack      in boolean  default false ,
  p_apex_env        in boolean  default false ,
  p_cgi_env         in boolean  default false ,
  p_console_env     in boolean  default false ,
  p_user_env        in boolean  default false ,
  p_user_agent      in varchar2 default null  ,
  p_user_scope      in varchar2 default null  ,
  p_user_error_code in integer  default null  ,
  p_user_call_stack in varchar2 default null  )
return console_logs.log_id%type;
```


## Procedure debug

Log a message with the level 4 (debug).

SIGNATURE

```sql
procedure debug (
  p_message         in clob     default null  ,
  p_permanent       in boolean  default false ,
  p_call_stack      in boolean  default false ,
  p_apex_env        in boolean  default false ,
  p_cgi_env         in boolean  default false ,
  p_console_env     in boolean  default false ,
  p_user_env        in boolean  default false ,
  p_user_agent      in varchar2 default null  ,
  p_user_scope      in varchar2 default null  ,
  p_user_error_code in integer  default null  ,
  p_user_call_stack in varchar2 default null  );
```


## Function debug

Log a message with the level 4 (debug). Returns the log ID.

SIGNATURE

```sql
function debug (
  p_message         in clob     default null  ,
  p_permanent       in boolean  default false ,
  p_call_stack      in boolean  default false ,
  p_apex_env        in boolean  default false ,
  p_cgi_env         in boolean  default false ,
  p_console_env     in boolean  default false ,
  p_user_env        in boolean  default false ,
  p_user_agent      in varchar2 default null  ,
  p_user_scope      in varchar2 default null  ,
  p_user_error_code in integer  default null  ,
  p_user_call_stack in varchar2 default null  )
return console_logs.log_id%type;
```


## Procedure trace

Log a message with the level 5 (trace).

SIGNATURE

```sql
procedure trace (
  p_message         in clob     default null  ,
  p_permanent       in boolean  default false ,
  p_call_stack      in boolean  default true  ,
  p_apex_env        in boolean  default true  ,
  p_cgi_env         in boolean  default true  ,
  p_console_env     in boolean  default true  ,
  p_user_env        in boolean  default true  ,
  p_user_agent      in varchar2 default null  ,
  p_user_scope      in varchar2 default null  ,
  p_user_error_code in integer  default null  ,
  p_user_call_stack in varchar2 default null  );
```


## Function trace

Log a message with the level 5 (trace). Returns the log ID.

SIGNATURE

```sql
function trace (
  p_message         in clob     default null  ,
  p_permanent       in boolean  default false ,
  p_call_stack      in boolean  default true  ,
  p_apex_env        in boolean  default true  ,
  p_cgi_env         in boolean  default true  ,
  p_console_env     in boolean  default true  ,
  p_user_env        in boolean  default true  ,
  p_user_agent      in varchar2 default null  ,
  p_user_scope      in varchar2 default null  ,
  p_user_error_code in integer  default null  ,
  p_user_call_stack in varchar2 default null  )
return console_logs.log_id%type;
```


## Procedure count

Creates a new counter with a value of one or adds one to an existing counter.

Does not depend on a log level, can be used anywhere to count things.

EXAMPLE

```sql
declare
  v_counter varchar2(30) := 'Processing xyz';
begin
  for i in 1 .. 10 loop
    console.count(v_counter);
  end loop;
  console.count_current(v_counter); -- without optional message

  for i in 1 .. 100 loop
    console.count(v_counter);
  end loop;
  console.count_current(v_counter, 'end of step two');

  for i in 1 .. 1000 loop
    console.count(v_counter);
  end loop;
  console.count_end(v_counter, 'end of step three');
end;
/
```

This will produce the following log messages in the table CONSOLE_LOGS when your
current log level is 3 (info) or higher:

- Processing xyz: 10
- Processing xyz: 110 - end of step two
- Processing xyz: 1110 - end of step three

SIGNATURE

```sql
procedure count ( p_label in varchar2 default null );
```


## Procedure count_reset

Reset an existing counter or create a new one.

Does not depend on a log level, can be used anywhere to count things.

Also see procedure `count` above.

SIGNATURE

```sql
procedure count_reset ( p_label in varchar2 default null );
```


## Procedure count_current

Log the current value of a counter, if the sessions log level is greater or
equal 3 (info).

Also see procedure `count` above.

SIGNATURE

```sql
procedure count_current (
  p_label   in varchar2 default null ,
  p_message in varchar2 default null );
```


## Procedure count_end

Log the current value of a counter, if the sessions log level is greater or
equal 3 (info). Delete the counter.

Also see procedure `count` above.

SIGNATURE

```sql
procedure count_end (
  p_label   in varchar2 default null ,
  p_message in varchar2 default null );
```


## Function count_current

Returns the current counter value or null, if the given label does not exist.

Does not depend on a log level, can be used anywhere to count things.

Also see procedure `count` above. The following example does not use the
optional label, therefore the implicit label used in the background will be
`default`. As we get only the value back from the funtion and we need only one
counter at the same time this is ok for us here and it keeps the code simple.


EXAMPLE

```sql
set serveroutput on

begin
  console.print('Counting nonsense...');
  for i in 1 .. 1000 loop
    if mod(i, 3) = 0 then
      console.count;
    end if;
  end loop;
  console.printf('Current value: %s', console.count_current );

  console.count_reset;
  for i in 1 .. 10 loop
    console.count;
  end loop;
  console.printf('Final value: %s', console.count_end );
end;

/
```

This will print something like the following to the server output:

```
Counting nonsense...
Current value: 333
Final value: 10
```

SIGNATURE

```sql
function count_current (
  p_label   in varchar2 default null )
return t_int;
```


## Function count_end

Returns the current counter value or null, if the given label does not exist.
Deletes the counter.

Does not depend on a log level, can be used anywhere to count things.

Also see function `count_current` above.

SIGNATURE

```sql
function count_end (
  p_label   in varchar2 default null )
return t_int;
```


## Procedure time

Create and a new timer. If the timer is already existing it will start again
with the current local timestamp.

Does not depend on a log level, can be used anywhere to measure runtime.

EXAMPLE

```sql
declare
  v_timer varchar2(30) := 'Processing xyz';
begin

  --basic usage
  console.time;
  sys.dbms_session.sleep(0.1);
  console.time_end; -- without optional label and message

  console.time(v_timer);

  sys.dbms_session.sleep(0.1);
  console.time_current(v_timer); -- without optional message

  sys.dbms_session.sleep(0.1);
  console.time_current(v_timer, 'end of step two');

  sys.dbms_session.sleep(0.1);
  console.time_end(v_timer, 'end of step three');

end;
/
```

This will produce the following log messages in the table CONSOLE_LOGS when your
current log level is 3 (info) or higher:

- default: 00:00:00.102508
- Processing xyz: 00:00:00.108048
- Processing xyz: 00:00:00.212045 - end of step two
- Processing xyz: 00:00:00.316084 - end of step three

SIGNATURE

```sql
procedure time ( p_label in varchar2 default null );
```


## Procedure time_reset

Reset an existing timer or create a new one.

Does not depend on a log level, can be used anywhere to measure runtime.

Also see procedure `time` above.

SIGNATURE

```sql
procedure time_reset ( p_label in varchar2 default null );
```


## Procedure time_current

Log the elapsed time, if the sessions log level is greater or equal 3 (info).

Can be called multiple times - use `console.time_end` to log the elapsed time
and delete the timer.

Also see procedure `time` above.

SIGNATURE

```sql
procedure time_current (
  p_label   in varchar2 default null ,
  p_message in varchar2 default null );
```


## Procedure time_end

Log the elapsed time and delete the timer, if the sessions log level is greater
or equal 3 (info).

Also see procedure `time` above.

SIGNATURE

```sql
procedure time_end (
  p_label   in varchar2 default null ,
  p_message in varchar2 default null );
```


## Function time_current

Returns the elapsed time as varchar in the format 00:00:00.000000 or null, if
the given label does not exist.

Does not depend on a log level, can be used anywhere to measure runtime.

Can be called multiple times - use `console.time_end` to return the elapsed time
and delete the timer.

Also see procedure `time` above. The following example does not use the optional
label, therefore the implicit label used in the background will be `default`. As
we get only the runtime back from the funtion in the format 00:00:00.000000 and
we need only one timer at the same time this is ok for us here and it keeps the
code simple.

EXAMPLE

```sql
set serveroutput on

begin
  console.time;

  console.print('Processing step one...');
  sys.dbms_session.sleep(0.1);
  console.printf('Elapsed time: %s', console.time_current);

  console.print('Processing step two...');
  sys.dbms_session.sleep(0.1);
  console.printf('Elapsed time: %s', console.time_current);

  console.print('Processing step three...');
  sys.dbms_session.sleep(0.1);
  console.printf('Elapsed time: %s', console.time_end);
end;
/
```

This will result in something like the following output:

```
Processing step one...
Elapsed time: 00:00:00.105398
Processing step two...
Elapsed time: 00:00:00.209267
Processing step three...
Elapsed time: 00:00:00.313301
```

SIGNATURE

```sql
function time_current ( p_label in varchar2 default null ) return varchar2;
```


## Function time_end

Returns the elapsed time as varchar in the format 00:00:00.000000 or null, if
the given label does not exist. Deletes the timer.

Does not depend on a log level, can be used anywhere to measure runtime.

Also see function `time_current` above.

SIGNATURE

```sql
function time_end ( p_label in varchar2 default null ) return varchar2;
```


## Procedure table#

Logs a cursor as a HTML table with the level 3 (info).

Using a cursor for the table method is very flexible, but opening a cursor can
produce unnecessary work for your system when you are not in the log level info.
Therefore please check your current log level before you open the cursor.

EXAMPLE

```sql
declare
  v_dataset sys_refcursor;
begin
  -- Your business logic here...

  -- Debug code
  if console.level_is_info then
    open v_dataset for
      select table_name,
             tablespace_name,
             logging,
             num_rows,
             last_analyzed,
             partitioned,
             has_identity
        from user_tables;
    console.table#(v_dataset);
  end if;

  -- Your business logic here...
end;
/
```

SIGNATURE

```sql
procedure table# (
  p_data_cursor       in sys_refcursor         ,
  p_comment           in varchar2 default null ,
  p_include_row_num   in boolean  default true ,
  p_max_rows          in integer  default 100  ,
  p_max_column_length in integer  default 1000 );
```


## Procedure assert

If the given expression evaluates to false, an error is raised with the given
message.

EXAMPLE

```sql
declare
  x number := 5;
  y number := 3;
begin
  console.assert(
    x < y,
    'x should be less then y (x=' || to_char(x) || ', y=' || to_char(y) || ')'
  );
exception
  when others then
    console.error;
    raise;
end;
/
```

SIGNATURE

```sql
procedure assert (
  p_expression in boolean,
  p_message    in varchar2
);
```


## Procedure assertf

If the given expression evaluates to false, an error is raised with the given
formatted message.

EXAMPLE

```sql
declare
  x number := 5;
  y number := 3;
begin
  console.assertf(
    x < y,
    'x should be less then y (x=%s, y=%s)',
    to_char(x),
    to_char(y)
  );
exception
  when others then
    console.error;
    raise;
end;
/
```

SIGNATURE

```sql
procedure assertf (
  p_expression in boolean               ,
  p_message    in varchar2              ,
  p0           in varchar2 default null ,
  p1           in varchar2 default null ,
  p2           in varchar2 default null ,
  p3           in varchar2 default null ,
  p4           in varchar2 default null ,
  p5           in varchar2 default null ,
  p6           in varchar2 default null ,
  p7           in varchar2 default null ,
  p8           in varchar2 default null ,
  p9           in varchar2 default null
);
```


## Procedure add_param

Add a parameter to the package internal parameter collection which will be
included in the next log call (error, warn, info, log, debug or trace)

The procedure is overloaded to support different parameter types.

VARCHAR and CLOB parameters are shortened to 2000 characters and additionally
escaped for Markdown table columns (replacing all line endings with whitespace
and the pipe character with `&#124;`). If you need your full parameter text then
please use the `p_message` CLOB parameter in the log methods error, warn, info,
log, debug and trace to do your own parameter handling.

```sql
procedure add_param ( p_name in varchar2, p_value in varchar2                       );
procedure add_param ( p_name in varchar2, p_value in number                         );
procedure add_param ( p_name in varchar2, p_value in date                           );
procedure add_param ( p_name in varchar2, p_value in timestamp                      );
procedure add_param ( p_name in varchar2, p_value in timestamp with time zone       );
procedure add_param ( p_name in varchar2, p_value in timestamp with local time zone );
procedure add_param ( p_name in varchar2, p_value in interval year to month         );
procedure add_param ( p_name in varchar2, p_value in interval day to second         );
procedure add_param ( p_name in varchar2, p_value in boolean                        );
procedure add_param ( p_name in varchar2, p_value in clob                           );
procedure add_param ( p_name in varchar2, p_value in xmltype                        );
```

EXAMPLE

```sql
--create demo procedure
create or replace procedure demo_proc (
  p_01 varchar2                       ,
  p_02 number                         ,
  p_03 date                           ,
  p_04 timestamp                      ,
  p_05 timestamp with time zone       ,
  p_06 timestamp with local time zone ,
  p_07 interval year to month         ,
  p_08 interval day to second         ,
  p_09 boolean                        ,
  p_10 clob                           ,
  p_11 xmltype                        )
is
begin
  raise_application_error(-20999, 'Demo Error.');
exception
  when others then
    console.add_param('p_01', p_01);
    console.add_param('p_02', p_02);
    console.add_param('p_03', p_03);
    console.add_param('p_04', p_04);
    console.add_param('p_05', p_05);
    console.add_param('p_06', p_06);
    console.add_param('p_07', p_07);
    console.add_param('p_08', p_08);
    console.add_param('p_09', p_09);
    console.add_param('p_10', p_10);
    console.add_param('p_11', p_11);
    console.error('Ooops, something went wrong');
    raise;
end demo_proc;
/

--run demo procedure
begin
  demo_proc (
    p_01 => 'test vc2'                             ,
    p_02 => 1.23                                   ,
    p_03 => sysdate                                ,
    p_04 => systimestamp                           ,
    p_05 => systimestamp                           ,
    p_06 => localtimestamp                         ,
    p_07 => interval '4-2' year to month           ,
    p_08 => interval '7 6:12:42.123' day to second ,
    p_09 => true                                   ,
    p_10 => to_clob('test clob')                   ,
    p_11 => xmltype('<test_xml/>')                 );
end;
/
```

SIGNATURE

```sql
procedure add_param ( p_name in varchar2, p_value in varchar2                       );
```


## Function format

Formats a message with the following rules:

1. Replace all occurrences of `%0` .. `%9` by id with the corresponding
   parameters `p0` .. `p9`
2. Replace `%n` with new lines (line feed character)
3. Replace all occurrences of `%s` in positional order with the corresponding
   parameters using sys.utl_lms.format_message - also see the [Oracle
   docs](https://docs.oracle.com/en/database/oracle/oracle-database/19/arpls/UTL_LMS.html#GUID-88FFBFB6-FCA4-4951-884B-B0275BD5DF44).

SIGNATURE

```sql
function format (
  p_message in varchar2              ,
  p0        in varchar2 default null ,
  p1        in varchar2 default null ,
  p2        in varchar2 default null ,
  p3        in varchar2 default null ,
  p4        in varchar2 default null ,
  p5        in varchar2 default null ,
  p6        in varchar2 default null ,
  p7        in varchar2 default null ,
  p8        in varchar2 default null ,
  p9        in varchar2 default null )
return varchar2;
```


## Procedure action

An alias for dbms_application_info.set_action.

Use the given action to set the session action attribute (in memory operation,
does not log anything). This attribute is then visible in the system session
views, the user environment and will be logged within all console logging
methods.

When you set the action attribute with `console.action` you should also reset it
when you have finished your work to prevent wrong info in the system and your
logging for subsequent method calls.

EXAMPLE

```sql
begin
  console.action('My process/task');
  -- do your stuff here...
  console.action(null);
exception
  when others then
    console.error('something went wrong');
    console.action(null);
    raise;
end;
/
```

SIGNATURE

```sql
procedure action ( p_action in varchar2 );
```


## Procedure module

An alias for dbms_application_info.set_module.

Use the given module and action to set the session module and action attributes
(in memory operation, does not log anything). These attributes are then visible
in the system session views, the user environment and will be logged within all
console logging methods.

Please note that your app framework may set the module and you should consider
to only set the action attribute with the `action` (see below).

SIGNATURE

```sql
procedure module (
  p_module in varchar2,
  p_action in varchar2 default null
);
```


## Function level_error

Returns the number code for the level 1 error.

SIGNATURE

```sql
function level_error     return integer;
```


## Function level_warning

Returns the number code for the level 2 warning.

SIGNATURE

```sql
function level_warning   return integer;
```


## Function level_info

Returns the number code for the level 3 info.

SIGNATURE

```sql
function level_info      return integer;
```


## Function level_debug

Returns the number code for the level 4 debug.

SIGNATURE

```sql
function level_debug     return integer;
```


## Function level_trace

Returns the number code for the level 5 trace.

SIGNATURE

```sql
function level_trace     return integer;
```


## Function level_is_warning

Returns true when the level is greater than or equal warning, otherwise false.

SIGNATURE

```sql
function level_is_warning return boolean;
```


## Function level_is_info

Returns true when the level is greater than or equal info, otherwise false.

SIGNATURE

```sql
function level_is_info    return boolean;
```


## Function level_is_debug

Returns true when the level is greater than or equal debug, otherwise false.

SIGNATURE

```sql
function level_is_debug   return boolean;
```


## Function level_is_trace

Returns true when the level is greater than or equal trace, otherwise false.

SIGNATURE

```sql
function level_is_trace   return boolean;
```


## Function level_is_warning_yn

Returns 'Y' when the level is greater than or equal warning, otherwise 'N'.

SIGNATURE

```sql
function level_is_warning_yn return varchar2;
```


## Function level_is_info_yn

Returns 'Y' when the level is greater than or equal info, otherwise 'N'.

SIGNATURE

```sql
function level_is_info_yn    return varchar2;
```


## Function level_is_debug_yn

Returns 'Y' when the level is greater than or equal debug, otherwise 'N'.

SIGNATURE

```sql
function level_is_debug_yn   return varchar2;
```


## Function level_is_trace_yn

Returns 'Y' when the level is greater than or equal trace, otherwise 'N'.

SIGNATURE

```sql
function level_is_trace_yn   return varchar2;
```


## Function apex_error_handling

You can register this example APEX error handler function to log APEX internal
errors.

To do so go into the Application Builder into your app > Edit Application
Properties > Error Handling > Error Handling Function. You can then provide here
`console.apex_error_handling`.

For more info see the [official
docs](https://docs.oracle.com/en/database/oracle/application-express/20.2/aeapi/Example-of-an-Error-Handling-Function.html#GUID-2CD75881-1A59-4787-B04B-9AAEC14E1A82).

The implementation code (see package body) is taken from the docs and aligned
for CONSOLE as a starting point. If this does not fit your needs then simply
reimplement an own function and use that instead.

SIGNATURE

```sql
function apex_error_handling ( p_error in apex_error.t_error )
return apex_error.t_error_result;
```


## Function apex_plugin_render

Used for the APEX plugin to capture frontend JavaScript errors.

If you plan to use the plugin make sure you have either console installed in
your APEX parsing schema or a synonym named `console` for it as this function is
referenced in the plug-in as a callback to `console.apex_plugin_render`.

SIGNATURE

```sql
function apex_plugin_render (
  p_dynamic_action in apex_plugin.t_dynamic_action ,
  p_plugin         in apex_plugin.t_plugin         )
return apex_plugin.t_dynamic_action_render_result;
```


## Function apex_plugin_ajax

Used for the APEX plugin to capture frontend JavaScript errors.

If you plan to use the plugin make sure you have either console installed in
your APEX parsing schema or a synonym named `console` for it as this function is
referenced in the plug-in as a callback to `console.apex_plugin_ajax`.

SIGNATURE

```sql
function apex_plugin_ajax (
  p_dynamic_action in apex_plugin.t_dynamic_action ,
  p_plugin         in apex_plugin.t_plugin         )
return apex_plugin.t_dynamic_action_ajax_result;
```


## Procedure conf

Set the global console configuration.

DO NOT USE THIS PROCEDURE IN YOUR BUSINESS LOGIC. IT IS INTENDED ONLY FOR
MANAGING GLOBAL PREFERENCES.

EXAMPLE

```sql
--set all sessions to level warning
exec console.conf(p_level => 2);
--or
exec console.conf(p_level => console.c_level_warning);

--set multiple options at once
begin
  console.conf(
    p_level             => console.c_level_info,
    p_check_interval    => 10
  );
end;
/
```

SIGNATURE

```sql
procedure conf (
  p_level            in integer default null , -- Level 1 (error), 2 (warning), 3 (info), 4 (debug) or 5 (trace).
  p_check_interval   in integer default null , -- The number of seconds a session looks for a changed configuration. Allowed values: 1 to 60 seconds.
  p_enable_ascii_art in boolean default null   -- Currently used to have more fun with the APEX error handling messages. But who knows...
);
```


## Procedure init

Init/set the preferences for a specific session/client_identifier and duration.

To avoid spoiling the context with very long input the parameter
p_client_identifier is truncated after 64 characters before using it.

For easier usage there is an overloaded procedure available which uses always
your own session/client_identifier.

DO NOT USE THIS PROCEDURE IN YOUR BUSINESS LOGIC. IT IS INTENDED ONLY FOR
MANAGING CLIENT PREFERENCES.

EXAMPLES

```sql
-- Dive into your own session with the default log level of 3 (info) and the
-- default duration of 60 (minutes).
exec console.init;

-- With level 4 (debug) for the next 15 minutes.
exec console.init(4, 15);

-- Using a constant for the level
exec console.init(console.c_level_debug, 90);

-- Debug an APEX session...
exec console.init('OGOBRECHT:8805903776765', 4, 90);

-- ...with named parameters
begin
  console.init(
    p_client_identifier => 'OGOBRECHT:8805903776765',
    p_level             => console.c_level_debug,
    p_duration          => 15
  );
end;
/
```

SIGNATURE

```sql
procedure init (
  p_client_identifier in varchar2                                  , -- The client identifier provided by the application or console itself.
  p_level             in integer  default c_level_info             , -- Level 2 (warning), 3 (info), 4 (debug) or 5 (trace).
  p_duration          in integer  default c_duration_default       , -- The number of minutes the session should be in client preferences mode. Allowed values: 1 to 1440 minutes (24 hours).
  p_check_interval    in integer  default c_check_interval_default , -- The number of seconds a session looks for a changed configuration. Allowed values: 1 to 60 seconds.
  p_call_stack        in boolean  default false                    , -- Should the call stack be included.
  p_user_env          in boolean  default false                    , -- Should the user environment be included.
  p_apex_env          in boolean  default false                    , -- Should the APEX environment be included.
  p_cgi_env           in boolean  default false                    , -- Should the CGI environment be included.
  p_console_env       in boolean  default false                      -- Should the console environment be included.
);
```


## Procedure init

An overloaded procedure for easier initialization of the own
session/client_identifier in an development IDE.

SIGNATURE

```sql
procedure init (
  p_level          in integer default c_level_info             , -- Level 2 (warning), 3 (info), 4 (debug) or 5 (trace).
  p_duration       in integer default c_duration_default       , -- The number of minutes the session should be in client preferences mode. Allowed values: 1 to 1440 minutes (24 hours).
  p_check_interval in integer default c_check_interval_default , -- The number of seconds a session in logging mode looks for a changed configuration. Allowed values: 1 to 60 seconds.
  p_call_stack     in boolean default false                    , -- Should the call stack be included.
  p_user_env       in boolean default false                    , -- Should the user environment be included.
  p_apex_env       in boolean default false                    , -- Should the APEX environment be included.
  p_cgi_env        in boolean default false                    , -- Should the CGI environment be included.
  p_console_env    in boolean default false                      -- Should the console environment be included.
);
```


## Procedure exit

Exit/unset the preferences for a specific session/client_identifier.

If you exit/unset your own client preferencs then this has an immediate effect
as we can unset the preferences in our package state. If you exit another
session/client_identifier then it can take some seconds until the other
session/client_identifier is reloading the configuration from the context (if
available) or the client_prefs table. The default check interval for a changed
configuration is ten seconds.

Exit/unset the preferences means also the cached log entries will be flushed to
the logging table CONSOLE_LOGS. If you do not need the cached entries you can
delete them in advance by calling the `clear` procedure.

DO NOT USE THIS PROCEDURE IN YOUR BUSINESS LOGIC. IT IS INTENDED ONLY FOR
MANAGING CLIENT PREFERENCES.

SIGNATURE

```sql
procedure exit (
  p_client_identifier in varchar2 default my_client_identifier -- The client identifier provided by the application or console itself.
);
```


## Procedure exit_all

Exit/unset all client preferences in one go.

EXAMPLE

```sql
exec console.exit_all;
```

SIGNATURE

```sql
procedure exit_all;
```


## Function version

Returns the version information from the console package.

```sql
select console.version from dual;
```

SIGNATURE

```sql
function version return varchar2;
```


## Procedure generate_param_trace

Generates parameter tracing code for you.

Writes to the server output - switch it on to see results. Input for parameter
`p_program` will be uppercased and spaces will be replaced by underscores. The
default for parameter `p_level` is 3 (info). These calls are all equivalent:

```sql
set serveroutput on
exec console.generate_param_trace('some api.do stuff');
exec console.generate_param_trace('Some_API.do_stuff', 3);
exec console.generate_param_trace('SOME_API.DO_STUFF', console.c_level_info);
begin
  console.generate_param_trace(
    p_program => 'SOME_API.DO_STUFF',
    p_level   => console.c_level_info
  );
end;
/
```

EXAMPLE 1

```sql
create or replace function demo_func (
  p_01 in     varchar2 ,
  p_02 in     number   ,
  p_03 in     date     )
return varchar2 is
begin
  null; --YOUR CODE HERE
end demo_func;
/
set serveroutput on
exec console.generate_param_trace('demo func');
```

This will output something like:

```sql
--------------------------------------------------------
-- Signature not recoverable with user_arguments
-- We start with declare for easier formatting
-- Your Program : DEMO_FUNC
-- Package Name : -
-- Object Name  : DEMO_FUNC
--------------------------------------------------------
declare
  procedure console_add_in_params is
  begin
    console.add_param('p_01', p_01);
    console.add_param('p_02', p_02);
    console.add_param('p_03', p_03);
  end console_add_in_params;
  procedure console_add_out_params is
  begin
    console.add_param('your_return_value', your_return_value);
  end console_add_out_params;
begin
  console_add_in_params;
  console.info('ENTER');
  --------------------
  -- YOUR CODE HERE
  --------------------
  console_add_out_params;
  console.info('LEAVE');
  ----------------------
  -- YOUR RETURN HERE
  ----------------------
exception
  when others then
    console_add_out_params;
    console.error;
    raise;
end;
/
```

As you can see in the procedure `console_add_out_params` you have to align the
name of your return variable (`console.add_param('your_return_value',
your_return_value)`).

EXAMPLE 2

```sql
create or replace procedure demo_proc (
  p_01 in     varchar2                       ,
  p_02 in     number                         ,
  p_03 in     date                           ,
  p_04 in     timestamp                      ,
  p_05 in     timestamp with time zone       ,
  p_06 in     timestamp with local time zone ,
  p_07 in     interval year to month         ,
  p_08 in     interval day to second         ,
  p_09 in     boolean                        ,
  p_10 in out clob                           ,
  p_11 in out xmltype                        ,
  p_12 in out console.t_client_prefs_row     ,
  p_13 in out console.t_client_prefs_tab     )
is
begin
  null; --YOUR CODE HERE
end demo_proc;
/
set serveroutput on
exec console.generate_param_trace('demo proc');
```

This will output something like:

```sql
--------------------------------------------------------
-- Signature not recoverable with user_arguments
-- We start with declare for easier formatting
-- Your Program : DEMO_PROC
-- Package Name : -
-- Object Name  : DEMO_PROC
--------------------------------------------------------
declare
  procedure console_add_in_params is
  begin
    console.add_param('p_01', p_01);
    console.add_param('p_02', p_02);
    console.add_param('p_03', p_03);
    console.add_param('p_04', p_04);
    console.add_param('p_05', p_05);
    console.add_param('p_06', p_06);
    console.add_param('p_07', p_07);
    console.add_param('p_08', p_08);
    console.add_param('p_09', p_09);
    console.add_param('p_10', p_10);
    console.add_param('p_11', p_11);
    --unsupported data type PL/SQL RECORD: console.add_param('p_12', p_12);
    --unsupported data type TABLE: console.add_param('p_13', p_13);
  end console_add_in_params;
  procedure console_add_out_params is
  begin
    console.add_param('p_10', p_10);
    console.add_param('p_11', p_11);
    --unsupported data type PL/SQL RECORD: console.add_param('p_12', p_12);
    --unsupported data type TABLE: console.add_param('p_13', p_13);
  end console_add_out_params;
begin
  console_add_in_params;
  console.info('ENTER');
  --------------------
  -- YOUR CODE HERE
  --------------------
  console_add_out_params;
  console.info('LEAVE');
exception
  when others then
    console_add_out_params;
    console.error;
    raise;
end;
/
```

As you can see in the output, unsupported data types for `console.add_param`
will be commented out.

SIGNATURE

```sql
procedure generate_param_trace (
  p_program in varchar2              , -- The package and/or program name ('some_api.do_stuff').
  p_level   in pls_integer default 3   -- The level you want to use for the parameter tracing.
);
```


## Function split_to_table

Splits a string into a (pipelined) SQL table of varchar2.

If the separator is null the string will be splitted into its characters.

EXAMPLE

```sql
select * from console.split_to_table('1,2,3');
```

| COLUMN_VALUE |
|--------------|
| 1            |
| 2            |
| 3            |

SIGNATURE

```sql
function split_to_table (
  p_string in varchar2             , -- The string to split into a table.
  p_sep    in varchar2 default ','   -- The separator.
) return t_vc2_tab pipelined;
```


## Function split

Splits a string into a PL/SQL associative array.

If the separator is null the string will be splitted into its characters.

EXAMPLE

```sql
set serveroutput on
declare
  v_array console.t_vc2_tab_i;
begin
  v_array := console.split('A,B,C');
  for i in 1 .. v_array.count loop
    console.print(i||': '||v_array(i));
  end loop;
end;
/

1: A
2: B
3: C
```

SIGNATURE

```sql
function split (
  p_string in varchar2             , -- The string to split into an array.
  p_sep    in varchar2 default ','   -- The separator.
) return t_vc2_tab_i;
```


## Function join

Joins a PL/SQL associative array into a string.

SIGNATURE

```sql
function join (
  p_table in t_vc2_tab_i          , -- The PL/SQL array to join into a string.
  p_sep   in varchar2 default ','   -- The separator.
) return varchar2;
```


## Function to_yn

Converts a boolean value to a string.

Returns `Y` when the input is true, `N` when the input is false and null when
the input is null.

SIGNATURE

```sql
function to_yn ( p_bool in boolean ) return varchar2;
```


## Function to_string

Converts a boolean value to a string.

Returns `true` when the input is true, `false` when the input is false and null
when the input is null.

SIGNATURE

```sql
function to_string ( p_bool in boolean ) return varchar2;
```


## Function to_bool

Converts a string to a boolean value.

Returns true when the uppercased, trimmed input is `TRUE`, `Y`, `YES` or `1`.
When the input is `FALSE`, `N`, `NO` or `0` false is returned. In all other
cases null is returned.

SIGNATURE

```sql
function to_bool ( p_string in varchar2 ) return boolean;
```


## Function to_html_table

Helper to convert a cursor to a HTML table.

Note: As this helper is designed to work always it does not check your log
level. And if it would check, it would not help for the opening of the cursor,
which is done before. To save work for your database in cases you are not in
logging mode you should check the log level before open the cursor. Please see the
examples below.

EXAMPLES 1 - Open cursor in advance

```sql
declare
  v_dataset sys_refcursor;
begin
  -- Your business logic here.

  -- Debug code
  if console.level_is_info then
    open v_dataset for select * from user_tables;
    console.info(console.to_html_table(v_dataset));
  end if;
end;
/
```

EXAMPLES 2 - Open cursor in for loop

```sql
begin
  -- Your business logic here.

  -- Debug code
  if console.my_log_level >= console.c_level_info then
    for i in (
      select console.to_html_table(cursor(select * from user_tables)) as html
        from dual )
    loop
      console.info(i.html);
    end loop;
  end if;
end;
/
```

SIGNATURE

```sql
function to_html_table (
  p_data_cursor       in sys_refcursor         ,
  p_comment           in varchar2 default null ,
  p_include_row_num   in boolean  default true ,
  p_max_rows          in integer  default 100  ,
  p_max_column_length in integer  default 1000 )
return clob;
```


## Function to_md_code_block

Converts the given text to a Markdown code block by indent each line with four
spaces.

SIGNATURE

```sql
function to_md_code_block (
  p_text in varchar2 )
return varchar2;
```


## Function to_md_tab_header

Converts the given key and value strings to a Markdown table header.

`to_md_tab_header` will return the following Markdown table header:

```md
| Attribute                      | Value                                       |
| ------------------------------ | ------------------------------------------- |
```

SIGNATURE

```sql
function to_md_tab_header (
  p_key   in varchar2 default 'Attribute' ,
  p_value in varchar2 default 'Value'     )
return varchar2;
```


## Function to_md_tab_data

Converts the given key and value strings to a Markdown table data row.

EXAMPLE

`to_md_tab_header('CLIENT_IDENTIFIER', '{o,o} 4C8E71DF0001')` will return the
following Markdown table row:

```md
| CLIENT_IDENTIFIER              | {o,o} 4C8E71DF0001                          |

```

SIGNATURE

```sql
function to_md_tab_data (
  p_key              in varchar2               ,
  p_value            in varchar2               ,
  p_value_max_length in integer  default 1000  ,
  p_show_null_values in boolean  default false )
return varchar2;
```


## Function to_unibar

Returns a text bar consisting of unicode block characters.

You can build simple text based bar charts with it. Not all fonts implement
clean block characters, so the result depends a little bit on the font. The
unicode block characters can have eight different widths from 1/8 up to 8/8 -
together with the default width of a bar chart of 25 characters you can show bar
charts with a precision of 0.5 percent - that is not bad for a text based bar
chart...

EXAMPLE

```sql
column textbar format a30

select 'Some text'       as description, 0.84 as value, console.to_unibar(0.84) as textbar from dual union all
select 'Some other text' as description, 0.75 as value, console.to_unibar(0.75) as textbar from dual union all
select 'Bla bla bla'     as description, 0.54 as value, console.to_unibar(0.54) as textbar from dual;
```

RESULT

```
DESCRIPTION          VALUE TEXTBAR
--------------- ---------- ------------------------------
Some text              .84 █████████████████████
Some other text        .75 ██████████████████▊
Bla bla bla            .54 █████████████▌
```

SIGNATURE

```sql
function to_unibar (
  p_value                   in number            ,
  p_scale                   in number default 1  ,
  p_width_block_characters  in number default 25 ,
  p_fill_scale              in number default 0
) return varchar2 deterministic;
```


## Procedure print

An alias for dbms_output.put_line.

Writing dbms_output.put_line is very annoying for me...

SIGNATURE

```sql
procedure print ( p_message in varchar2 );
```


## Procedure printf

A shorthand for

```
begin
  console.print(console.format('A string with %s %s.', 'dynamic', 'content'));
  --is equivalent to
  console.printf('A string with %s %s.', 'dynamic', 'content');
end;
/
```

Also see [console.format](#function-format)

SIGNATURE

```sql
procedure printf (
  p_message in varchar2              ,
  p0        in varchar2 default null ,
  p1        in varchar2 default null ,
  p2        in varchar2 default null ,
  p3        in varchar2 default null ,
  p4        in varchar2 default null ,
  p5        in varchar2 default null ,
  p6        in varchar2 default null ,
  p7        in varchar2 default null ,
  p8        in varchar2 default null ,
  p9        in varchar2 default null );
```


## Function runtime

Returns a string in the format hh24:mi:ss.ff6 (for example 00:00:01.123456).

Is internally used by the `time_end` method and uses `localtimestamp` to compare
with `p_start`.

EXAMPLE

```sql
set serveroutput on
declare
  v_start timestamp := localtimestamp;
begin

  --do your stuff here

  dbms_output.put_line('Runtime: ' || console.runtime(v_start));
end;
/
```

SIGNATURE

```sql
function  runtime ( p_start in timestamp ) return varchar2;
```


## Function runtime_seconds

Subtracts the start `localtimestamp` from the current `localtimestamp` and
returns the exracted seconds.

EXAMPLE

```sql
set serveroutput on
declare
  v_start timestamp := localtimestamp;
begin

  --do your stuff here

  dbms_output.put_line (
    'Runtime (seconds): ' || to_char(console.runtime_seconds(v_start)) );
end;
/
```

SIGNATURE

```sql
function runtime_seconds ( p_start in timestamp ) return number;
```


## Function runtime_milliseconds

Subtracts the start `localtimestamp` from the current `localtimestamp` and
returns the exracted milliseconds.

EXAMPLE

```sql
set serveroutput on
declare
  v_start timestamp := localtimestamp;
begin

  --do your stuff here

  dbms_output.put_line (
    'Runtime (milliseconds): ' || to_char(console.runtime_milliseconds(v_start)) );
end;
/
```

SIGNATURE

```sql
function runtime_milliseconds ( p_start in timestamp ) return number;
```


## Function level_name

Returns the level name for a given level id and null, if the level is not
between 0 and 4.

SIGNATURE

```sql
function level_name (p_level in integer) return varchar2 deterministic;
```


## Function scope

Get the current scope (method, line number) from the call stack.

Is used internally by console to automatically provide the scope attribute for a
log entry.

SIGNATURE

```sql
function scope return varchar2;
```


## Function call_stack

Get the current call stack (and error stack/backtrace, if available).

Is used internally by console to provide the call stack for a log entry when
requested by one of the logging methods (which is the default for error and
trace).

SIGNATURE

```sql
function call_stack return varchar2;
```


## Function apex_env

Get the current APEX environment.

Is used internally by console to provide the APEX environment for a log entry
when requested by one of the logging methods.

SIGNATURE

```sql
function apex_env return clob;
```


## Function cgi_env

Get the current CGI environment.

Is used internally by console to provide the CGI environment for a log entry
when requested by one of the logging methods.

SIGNATURE

```sql
function cgi_env return varchar2;
```


## Function user_env

Get the current user environment.

Is used internally by console to provide the user environment for a log entry
when requested by one of the logging methods.

SIGNATURE

```sql
function user_env return varchar2;
```


## Function console_env

Get the current console environment.

Is used internally by console to provide the console environment for a log entry
when requested by one of the logging methods.

SIGNATURE

```sql
function console_env return varchar2;
```


## Procedure clob_append

High performance clob concatenation. Also see clob_flush_cache below.

Is used internally by console for the table method (and other things). Do not
forget a final flush cache call when you use it in your own code.

EXAMPLE

```sql
set serveroutput on feedback off
declare
  v_start  timestamp := localtimestamp;
  v_clob   clob;
  v_cache  varchar2(32767 char);
begin
  for i in 1..100000 loop
    console.clob_append(v_clob, v_cache, 'a');
  end loop;
  console.clob_flush_cache(v_clob, v_cache);
  dbms_output.put_line('Runtime (seconds): ' || to_char(console.runtime_seconds(v_start)));
  dbms_output.put_line('Lenght CLOB      : ' || length(v_clob));
end;
/
```

SIGNATURE

```sql
procedure clob_append (
  p_clob  in out nocopy clob     ,
  p_cache in out nocopy varchar2 ,
  p_text  in            varchar2 );
```


## Procedure clob_append

High performance clob concatenation.

Overloaded method for appending a clob. Also see clob_append above with p_text
beeing a varchar2 parameter and clob_flush_cache below.

SIGNATURE

```sql
procedure clob_append (
  p_clob  in out nocopy clob     ,
  p_cache in out nocopy varchar2 ,
  p_text  in            clob     );
```


## Procedure clob_flush_cache

Flushes finally the cache in a high performance clob concatenation.

Also see clob_append above.

SIGNATURE

```sql
procedure clob_flush_cache (
  p_clob  in out nocopy clob     ,
  p_cache in out nocopy varchar2 );
```


## Function status

View the current package status (config, number entries cache/timer/counter,
version etc.).

EXAMPLE

```sql
select * from console.status();
```

SIGNATURE

```sql
function status return t_attribute_value_tab pipelined;
```


## Function conf

View the global console configuration.

EXAMPLE

```sql
select * from console.conf();
```

SIGNATURE

```sql
function conf return t_attribute_value_tab pipelined;
```


## Function client_prefs

View the client preferences.

EXAMPLE

```sql
select * from console.client_prefs();
```

SIGNATURE

```sql
function client_prefs return t_client_prefs_tab pipelined;
```


## Procedure purge

Deletes log entries for the given condition.

Deletion is only allowed for the owner of the package console.

EXAMPLES

```sql
--> default: all level info, debug and trace older than 30 days
exec console.purge;

--> all three examples are equivalent
exec console.purge(3, 0.25);
exec console.purge(console.c_level_info, 0.25);
exec console.purge(p_min_level => console.c_level_info, p_min_days => 0.25);
```

SIGNATURE

```sql
procedure purge (
  p_min_level in integer default c_level_info, -- Delete log entries greater or equal the given level.
  p_min_days  in number  default 30 );         -- Delete log entries older than the given minimum days.
```


## Procedure purge_all

Deletes all log entries except level permanent.

Deletion is only allowed for the owner of the package console.

EXAMPLE

```sql
exec console.purge_all;
```

SIGNATURE

```sql
procedure purge_all;
```


## Procedure purge_job_create

Creates a cleanup job which deletes old log entries from console_logs and stale
debug sessions from console_client_prefs.

SIGNATURE

```sql
procedure purge_job_create (
  p_repeat_interval in varchar2 default 'FREQ=DAILY;BYHOUR=1;' , -- See the Oracle docs: https://docs.oracle.com/en/database/oracle/oracle-database/19/admin/scheduling-jobs-with-oracle-scheduler.html#GUID-10B1E444-8330-4EC9-85F8-9428D749F7D5
  p_min_level       in integer  default c_level_info           , -- Delete log entries greater or equal the given level.
  p_min_days        in number   default 30                       -- Delete log entries older than the given minimum days.
);
```


## Procedure purge_job_drop

Drops the cleanup job (if it exists).

SIGNATURE

```sql
procedure purge_job_drop;
```


## Procedure purge_job_enable

Enables the cleanup job (if it exists).

SIGNATURE

```sql
procedure purge_job_enable;
```


## Procedure purge_job_disable

Disables the cleanup job (if it exists).

SIGNATURE

```sql
procedure purge_job_disable;
```


## Procedure purge_job_run

Runs the cleanup job (if it exists).

SIGNATURE

```sql
procedure purge_job_run;
```


